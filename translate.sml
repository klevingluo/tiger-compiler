(* So from what I understand, this is the value environment compared to typenv's
 * type environment.  This is more complicated than the type environment because
 * values are mutable at run time.  They key thing that I think andrew is trying
 * to have us figure out is that the translate levels are created during
 * analysis and the frame levels are created during runtime.
 *
 * note:
 * This to me indicates that a level needs to have a parent and some set of
 * machine instructions for generating a new frame.
 *)
(* TODO: check pointers for nil before dereferencing *)
(* TODO: check array indices before accessing *)
signature TRANSLATE =
sig
  type level
  type access (* not the same as Frame.access *)
  datatype exp = Ex of Tree.exp
               | Nx of Tree.stm
               | Cx of Temp.label * Temp.label -> Tree.stm

  val outermost  : level
  val newLevel   : {parent: level, name: Temp.label, formals: bool list} -> level
  val formals    : level -> access list
  val allocLocal : level -> bool -> access

  (* functions for translating variables *)
  val simpleVar    : access * level -> exp
  val fieldVar     : exp * int -> exp
  val subscriptVar : exp * int -> exp

  (* instructions for translating expressions*)
  val nilExp    : int -> exp
  val intExp    : int -> exp
  val stringExp : string -> exp
  val callExp   : exp * exp list -> exp
  val opExp     : exp * Absyn.oper * exp -> exp
  val recordExp : int -> exp
  val seqExp    : int -> exp
  val assignExp : int -> exp
  val ifExp     : exp * exp * exp option -> exp
  val whileExp  : int -> exp
  val forExp    : int -> exp
  val breakExp  : int -> exp
  val letExp    : int -> exp
  val arrayExp  : int -> exp
end

structure Translate : TRANSLATE = 
struct 
  structure Frame : FRAME = MipsFrame
  structure T = Tree
  structure A = Absyn

  datatype level = BASE | LEV of (level * Frame.frame * unit ref)
  type access = (level * Frame.access) 

  (* Ex : calculated for value 
   * Nx : calculated for side effect 
   * Cx : calculated for control *)
  datatype exp = Ex of Tree.exp
               | Nx of Tree.stm
               | Cx of Temp.label * Temp.label -> Tree.stm

  (* helper function for generating statement sequences *)
  fun seq(x::rest) = 
    T.SEQ(x, seq(rest))
    | seq(x::[]) = x

  fun formals(LEV(lvl, frm, frmref)) = map(fn x => (lvl, x))(Frame.formals(frm))

  (* helper function for generating expression sequences *)
  fun eseq(stms) = 
    let 
      val reved = rev stms
      val last = hd reved
      val rest = rev (tl (rev reved))
    in
      case last of
           (T.EXP e) => T.ESEQ(seq(rest), e)
    end

  (* list of fragments generated by the compiler *)
  val frags : Frame.frag list ref = ref []

  (* unpack an exp as if it were of a certain type*)
  fun unEx(Ex e) = e
    | unEx(Cx genstm) =
          let val r = Temp.newtemp()
              val t = Temp.newlabel()
              val f = Temp.newlabel()
          in T.ESEQ(seq[T.MOVE(T.TEMP r, T.CONST 1),
                        genstm(t,f),
                        T.LABEL f,
                        T.MOVE(T.TEMP r, T.CONST 0),
                        T.LABEL t],
                    T.TEMP r)
          end
    | unEx(Nx s) = T.ESEQ(s, T.CONST 0)
  fun unNx(Ex e) = T.EXP e
    | unNx(Nx s) = s
    | unNx(Cx genstm) = 
      let val t = Temp.newlabel() 
      in seq([genstm(t,t), T.LABEL t])
      end
  fun unCx(Ex (T.CONST 0)) = (fn (t,f) => T.JUMP(T.NAME f, [f]))
    | unCx(Ex (T.CONST 1)) = (fn (t,f) => T.JUMP(T.NAME t, [t]))
    | unCx(Ex e) = (fn (t, f) => T.CJUMP(T.EQ, T.CONST 1, e, t, f))
    (* this should never happen in a valid tiger program *)
    | unCx(Nx s) = (fn (t, f) => T.JUMP(T.NAME f, [f]))
    | unCx(Cx genstm) = genstm

  (* this is the level that housees the program.  "library" functions are
   * declared at this level, which does not contain a frame, nor a parameter
   * list *)
  val outermost = BASE

  (* called during the translation of declarations *)
  fun newLevel({parent, name, formals}) =
    LEV(parent,
        Frame.newFrame({name=name, formals=true::formals}),
        ref ())

  (* called whenever a local variable is declared *)
  fun allocLocal(LEV(parent, frm, frmref) : level)(esc) =
      (LEV(parent, frm, frmref), Frame.allocLocal(frm)(esc))

(* Code for handling variables starts here *)
  fun simpleVar((LEV(parent, accfrm, accref), acc), LEV(level, frame, frmref)) =
    let 
      fun getFrame(accref, (parent, frame, frmref)) =
        if accref = frmref
        then T.TEMP(Frame.FP)
        else case level of
                  LEV(lev, frm, frmr) => T.MEM(
                                           T.BINOP(
                                           T.PLUS,
                                           T.CONST 1,
                                         getFrame(accref, (lev,frm,frmr))))
         (* our typechecker guarantees this will be found*)
    in
      Frame.exp(acc)(getFrame(accref, (parent, frame, frmref)))
    end

  (* tiger is simplified because all lvalues are of the same size *)
  fun subscriptVar(var : T.exp, ind : int) = 
    Ex(T.MEM(T.BINOP(T.PLUS, 
                     T.BINOP(T.MUL, T.CONST Frame.wordSize, T.CONST ind), 
                     var)))

  fun fieldVar(var : exp, ind : int) = 
    Ex(T.MEM(T.BINOP(T.PLUS, 
                     T.BINOP(T.MUL, 
                             T.CONST Frame.wordSize, 
                             T.CONST ind), 
                     unEx(var))))

(* code for handling expressions starts here *)
  (* TODO:  fix the issue with lvalues *)
  fun initialize(var : T.exp, val' : T.exp) =
    Nx(T.MOVE(var, val'))

  fun opExp(left, oper, right) : exp =
    case oper
      of A.PlusOp   => 
           Ex(T.BINOP(T.PLUS, unEx(left), unEx(right)))
       | A.MinusOp  =>
           Ex(T.BINOP(T.MINUS, unEx(left), unEx(right)))
       | A.TimesOp  =>
           Ex(T.BINOP(T.MUL, unEx(left), unEx(right)))
       | A.DivideOp =>
           Ex(T.BINOP(T.DIV, unEx(left), unEx(right)))
       | A.EqOp     => 
           Cx(fn(t,f) => T.CJUMP(T.EQ, unEx(left), unEx(right), t, f))
       | A.NeqOp    => 
           Cx(fn(t,f) => T.CJUMP(T.NE, unEx(left), unEx(right), t, f))
       | A.LtOp     =>
           Cx(fn(t,f) => T.CJUMP(T.LT, unEx(left), unEx(right), t, f))
       | A.LeOp     =>
           Cx(fn(t,f) => T.CJUMP(T.LE, unEx(left), unEx(right), t, f))
       | A.GtOp     =>
           Cx(fn(t,f) => T.CJUMP(T.GT, unEx(left), unEx(right), t, f))
       | A.GeOp     =>
           Cx(fn(t,f) => T.CJUMP(T.GE, unEx(left), unEx(right), t, f))

  (* we don't need to store the value of this expression, which is computer for
   * its side efects *)
  fun ifExp(test, Nx s1, SOME(Nx s2)) : exp =
        (let
          val t = Temp.newlabel()
          val f = Temp.newlabel()
          val j = Temp.newlabel()
        in
          Nx(seq([
            unCx(test)(t,f),
            T.LABEL t,
            s1,
            T.JUMP(T.NAME j, [j]),
            T.LABEL f,
            s2,
            T.LABEL j
          ]))
        end)
    | ifExp(test, Nx s1, NONE) =
        let
          val t = Temp.newlabel()
          val f = Temp.newlabel()
          val j = Temp.newlabel()
        in
          Nx(seq([
            unCx(test)(t,f),
            T.LABEL t,
            s1,
            T.LABEL f
          ]))
        end
    (* we can optimize if we have two Cx's *)
    | ifExp(test, Cx s1, SOME(Cx s2)) =
      let 
        val a = Temp.newlabel()
        val b = Temp.newlabel()
      in
          Cx (fn(t,f) => 
            seq([
                 unCx(test)(a,b),
                 T.LABEL a,
                 s1(t, f),
                 T.LABEL b,
                 s2(t, f)
               ]))
      end
      (* we can optimize if we have only one Cx *)
    | ifExp(test, Cx s, NONE) =
        let
          val a = Temp.newlabel()
        in
          Cx (fn(t,f) => 
            seq([
                 unCx(test)(a,f),
                 T.LABEL a,
                 s(t, f)
               ]))
        end
      (* at this point, we know that we're computing for value so we need to save
       * the value to a register *)
    | ifExp(test, then', SOME(else')) =
        let
          val t = Temp.newlabel()
          val f = Temp.newlabel()
          val j = Temp.newlabel()
          val r = Temp.newtemp()
        in
          Ex(eseq([
            unCx(test)(t,f),
            T.LABEL t,
            T.MOVE(T.TEMP r, unEx then'),
            T.JUMP(T.NAME j, [j]),
            T.LABEL f,
            T.MOVE(T.TEMP r, unEx else'),
            T.LABEL j,
            T.EXP(T.TEMP r)
          ]))
        end

  (* array: exp * exp -> exp *)
  (* initArray simply takes the array length and initializing
   * value *)
  fun array(size, init) =
    Frame.externalCall("initArray", [unEx(size), unEx(init)])

  (* fieldVar: exp * symbol * symbol list -> exp *)
  (* Records are allocated in the order of their fields, so we just have to
   * determine the corresponding offset into the record *)
  fun fieldVar(recordExp, field, fields) =
    let 
      fun findOffset(offset, aField, rField::rFields) =
            if aField = rField
            then offset
            else findOffset(offset + 1, aField, rFields)
        | findOffset(offset, aField, last) =offset
      (* should be safe to assume if we haven't found it yet..  *)
    in
      Ex(T.MEM(T.BINOP(T.PLUS,
                       unEx(recordExp),
                       T.BINOP(T.MUL, 
                               T.CONST(findOffset(0, field, fields)),
                               T.CONST(Frame.wordSize)))))
    end

  (* handles sequences of expresssions *)
  fun sequence(trans) =
    Ex(eseq(trans))

  (* it looks like the tiger runtime knows to treat the left hand side as a
   * location, rather than a value. *)
  fun assign(lval, rval) =
    Nx(T.MOVE(unEx lval, unEx rval))

  (* implementation of while loops *)
  fun whileExp(test, body) =
    let
      val checklab = Temp.newlabel()
      val bodylab = Temp.newlabel()
      val donelab = Temp.newlabel()
    in
      Nx(seq([
        T.LABEL checklab,
        unCx(test)(bodylab, donelab),
        T.LABEL bodylab,
        unNx body,
        T.JUMP(T.NAME checklab, [checklab]),
        T.LABEL donelab
      ]))
    end

  (* nil is just a constant 0 *)
  fun nil() = T.CONST 0
  
  (* handles integer consts *)
  fun int(i) = T.CONST i

  (* saves a string literal as a name, and a fragment to frags *)
  fun string(lit) = 
    let
      val lab= Temp.newlabel()
    in
      (frags := Frame.STRING(lab, lit):: !frags;
       T.NAME(lab))
    end

  (* handles function calls *)
  fun call(func, args) = 
    T.CALL(T.MEM func, args)

  (* allocates some heap space for a record the fields placed in order of the
   * type declaration *)
  fun record(fields) =
    let
      val r = Temp.newtemp()
      val ind = ref 0
      (* create all of the move instructions *)
      fun genstm(exp::rest) =
        let val i = !ind
        in
          (ind := !ind +1;
           T.MOVE(T.MEM(T.BINOP(T.PLUS, 
                                T.TEMP r,
                                T.CONST i)),
                  unEx exp)::genstm([]))
        end
        | genstm([]) = []
    in
      T.ESEQ(seq(
             T.MOVE(T.TEMP r,Frame.externalCall("malloc", 
                                         [T.BINOP(T.MUL, 
                                                  T.CONST Frame.wordSize, 
                                                  T.CONST(length(fields)))]))
             :: genstm(fields)), 
             T.TEMP r)
    end

  (* function calls *)
  fun procEntryExit(LEV(lev, frm, frmref), exp) : unit =
    let
      val lab= Temp.newlabel
    in
      (frags := Frame.PROC({body=exp, frame=frm}):: !frags;
       ())
    end
    

  (* returns the list of frags that we have *)
  fun getResult() = !frags

  type exp = unit 
end
