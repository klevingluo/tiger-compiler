(* So from what I understand, this is the value environment compared to typenv's
 * type environment.  This is more complicated than the type environment because
 * values are mutable at run time.  They key thing that I think andrew is trying
 * to have us figure out is that the translate levels are created during
 * analysis and the frame levels are created during runtime.
 *
 * note:
 * This to me indicates that a level needs to have a parent and some set of
 * machine instructions for generating a new frame.
 *)
(* TODO: check pointers for nil before dereferencing *)
(* TODO: check array indices before accessing *)
signature TRANSLATE =
sig
  type level
  type access (* not the same as Frame.access *)
  type exp

  val outermost  : level
  val newLevel   : {parent: level, name: Temp.label, formals: bool list} -> level
  val formals    : level -> access list
  val allocLocal : level -> bool -> access

  (* functions for translating variables *)
  val simpleVar    : access * level -> exp
  val fieldVar     : exp * int -> exp
  val subscriptVar : exp * exp -> exp

  val unEx : exp -> Tree.exp
  val unNx : exp -> Tree.stm
  val unCx : exp -> Temp.label * Temp.label -> Tree.stm

  val procEntryExit : level * exp -> unit
  val initialize : exp * exp -> exp

  (* instructions for translating expressions*)
  val nilExp    : unit -> exp
  (* Tree expression representing no computation *)
  val unitExp   : unit -> exp
  val intExp    : int -> exp
  val stringExp : string -> exp
  val callExp   : Temp.label * exp list -> exp
  val opExp     : exp * Absyn.oper * exp -> exp
  val recordExp : exp list -> exp
  val seqExp    : exp list -> exp
  val assignExp : exp * exp -> exp
  val ifExp     : exp * exp * exp option -> exp
  val whileExp  : exp * exp * Temp.label -> exp
  val breakExp  : Temp.label -> exp
  val letExp    : exp list * exp -> exp
  val arrayExp  : exp * exp -> exp
  (* TODO: fix break, let and for *)

  val printtree : exp -> unit
end

structure Translate : TRANSLATE = 
struct 
  structure Frame : FRAME = MipsFrame
  structure T = Tree
  structure A = Absyn

  (* Ex : An expression computed for value 
   * Nx : A statement computed for its side effects
   * Cx : An expression computed determine where to send control *)
  datatype exp = Ex of Tree.exp
               | Nx of Tree.stm
               | Cx of Temp.label * Temp.label -> Tree.stm

  (* A level is either the base level, or a new frame with a referece to the
   * previous level and a unit ref for comparison *)
  datatype level = BASE | LEV of (level * Frame.frame * unit ref)
  type access = (level * Frame.access) 

  (* helper function for generating statement sequences from a list of Tree
   * statements. *)
  fun seq(x::[]) = x
    | seq(x::rest) = T.SEQ(x, seq(rest))
    (* the empty list of sequences is represented by the 0 expression *)
    | seq([]) = T.EXP(T.CONST 0)

  (* Gets the formals of a frame *)
  fun formals(LEV(lvl, frm, frmref)) = map(fn x => (lvl, x))(Frame.formals(frm))
    | formals(_) = raise Fail "taking formals of BASE"

  (* helper function for generating expression sequences *)
  fun eseq(stms) = 
    case rev stms of 
         [] => (T.CONST 0)
       | head::[] =>
         (case head of
               (T.EXP e) => e
             | _ => T.ESEQ(head, T.CONST 0))
       | head::rest =>
         (case head of
               (T.EXP e) => T.ESEQ(seq(rev rest), e)
             | _ => T.ESEQ(seq(stms), T.CONST 0))

  (* list of fragments generated by the compiler *)
  val frags : Frame.frag list ref = ref []

  (* returns the list of frags that we have *)
  fun getResult() = !frags

  (* unpack an Translate.exp as if it were of a certain type*)
  fun unEx(Ex e) = e
    | unEx(Cx genstm) =
          let val r = Temp.newtemp()
              val t = Temp.newlabel()
              val f = Temp.newlabel()
          in T.ESEQ(seq([T.MOVE(T.TEMP r, T.CONST 1),
                        genstm(t,f),
                        T.LABEL f,
                        T.MOVE(T.TEMP r, T.CONST 0),
                        T.LABEL t]),
                    T.TEMP r)
          end
    | unEx(Nx s) = T.ESEQ(s, T.CONST 0)
  fun unNx(Ex e) = T.EXP e
    | unNx(Nx s) = s
    | unNx(Cx genstm) = 
      let val t = Temp.newlabel() 
      in seq([genstm(t,t), T.LABEL t])
      end
  fun unCx(Ex (T.CONST 0)) = (fn (t,f) => T.JUMP(T.NAME f, [f]))
    | unCx(Ex (T.CONST 1)) = (fn (t,f) => T.JUMP(T.NAME t, [t]))
    | unCx(Ex e) = (fn (t, f) => T.CJUMP(T.EQ, T.CONST 1, e, t, f))
    (* this should never happen in a valid tiger program *)
    | unCx(Nx s) = (fn (t, f) => T.JUMP(T.NAME f, [f]))
    | unCx(Cx genstm) = genstm


  (* called during the translation of declarations *)
  fun newLevel({parent, name, formals}) =
    LEV(parent,
        Frame.newFrame({name=name, formals=true::formals}),
        ref ())

  (* this is the level that housees the program.  "library" functions are
   * declared at this level, which does not contain a frame, nor a parameter
   * list *)
  val outermost = newLevel({parent=BASE,
                            name=Temp.newlabel(),
                            formals=[]})

  (* called whenever a local variable is declared *)
  fun allocLocal(LEV(parent, frm, frmref) : level)(esc) =
      (LEV(parent, frm, frmref), Frame.allocLocal(frm)(esc))
    | allocLocal(BASE)(_) = raise Fail "trying to create variable at base frame"

(* Code for handling variables starts here *)
  fun simpleVar((LEV(parent, accfrm, accref), acc), LEV(level, frame, frmref)) =
    let 
      fun getFrame(accref, (parent, frame, frmref)) =
        if accref = frmref
        then T.TEMP(Frame.FP)
        else case level of
                  LEV(lev, frm, frmr) => T.MEM(
                                           T.BINOP(
                                           T.PLUS,
                                           T.CONST 1,
                                         getFrame(accref, (lev,frm,frmr))))
                | BASE => T.CONST 3
                (* TODO: fix this *)
         (* our typechecker guarantees this will be found*)
    in
      Ex(Frame.exp(acc)(getFrame(accref, (parent, frame, frmref))))
    end
    | simpleVar(_, _) = raise Fail "nonexaustive match"

  (* tiger is simplified because all lvalues are of the same size *)
  fun subscriptVar(var : exp, ind : exp) = 
    Ex(T.MEM(T.BINOP(T.PLUS, 
                     T.BINOP(T.MUL, T.CONST Frame.wordSize, unEx(ind)), 
                     unEx(var))))

  fun fieldVar(var : exp, ind : int) : exp = 
    Ex(T.MEM(T.BINOP(T.PLUS, 
                     T.BINOP(T.MUL, 
                             T.CONST Frame.wordSize, 
                             T.CONST ind), 
                     unEx(var))))

(* code for handling expressions starts here *)
  fun initialize(var : exp, val' : exp) =
    Nx(T.MOVE(unEx(var), unEx(val')))

  fun opExp(left, oper, right) : exp =
    case oper
      of A.PlusOp   => 
           Ex(T.BINOP(T.PLUS, unEx(left), unEx(right)))
       | A.MinusOp  =>
           Ex(T.BINOP(T.MINUS, unEx(left), unEx(right)))
       | A.TimesOp  =>
           Ex(T.BINOP(T.MUL, unEx(left), unEx(right)))
       | A.DivideOp =>
           Ex(T.BINOP(T.DIV, unEx(left), unEx(right)))
       | A.EqOp     => 
           Cx(fn(t,f) => T.CJUMP(T.EQ, unEx(left), unEx(right), t, f))
       | A.NeqOp    => 
           Cx(fn(t,f) => T.CJUMP(T.NE, unEx(left), unEx(right), t, f))
       | A.LtOp     =>
           Cx(fn(t,f) => T.CJUMP(T.LT, unEx(left), unEx(right), t, f))
       | A.LeOp     =>
           Cx(fn(t,f) => T.CJUMP(T.LE, unEx(left), unEx(right), t, f))
       | A.GtOp     =>
           Cx(fn(t,f) => T.CJUMP(T.GT, unEx(left), unEx(right), t, f))
       | A.GeOp     =>
           Cx(fn(t,f) => T.CJUMP(T.GE, unEx(left), unEx(right), t, f))

  (* we don't need to store the value of this expression, which is computer for
   * its side efects *)
  fun ifExp(test, Nx s1, SOME(Nx s2)) : exp =
        (let
          val t = Temp.newlabel()
          val f = Temp.newlabel()
          val j = Temp.newlabel()
        in
          Nx(seq([
            unCx(test)(t,f),
            T.LABEL t,
            s1,
            T.JUMP(T.NAME j, [j]),
            T.LABEL f,
            s2,
            T.LABEL j
          ]))
        end)
    | ifExp(test, Nx s1, NONE) =
        let
          val t = Temp.newlabel()
          val f = Temp.newlabel()
          val j = Temp.newlabel()
        in
          Nx(seq([
            unCx(test)(t,f),
            T.LABEL t,
            s1,
            T.LABEL f
          ]))
        end
    (* we can optimize if we have two Cx's *)
    | ifExp(test, Cx s1, SOME(Cx s2)) =
      let 
        val a = Temp.newlabel()
        val b = Temp.newlabel()
      in
          Cx (fn(t,f) => 
            seq([
                 unCx(test)(a,b),
                 T.LABEL a,
                 s1(t, f),
                 T.LABEL b,
                 s2(t, f)
               ]))
      end
      (* we can optimize if we have only one Cx *)
    | ifExp(test, Cx s, NONE) =
        let
          val a = Temp.newlabel()
        in
          Cx (fn(t,f) => 
            seq([
                 unCx(test)(a,f),
                 T.LABEL a,
                 s(t, f)
               ]))
        end
      (* at this point, we know that we're computing for value so we need to save
       * the value to a register *)
    | ifExp(test, then', SOME(else')) =
        let
          val t = Temp.newlabel()
          val f = Temp.newlabel()
          val j = Temp.newlabel()
          val r = Temp.newtemp()
        in
          Ex(eseq([
            unCx(test)(t,f),
            T.LABEL t,
            T.MOVE(T.TEMP r, unEx then'),
            T.JUMP(T.NAME j, [j]),
            T.LABEL f,
            T.MOVE(T.TEMP r, unEx else'),
            T.LABEL j,
            T.EXP(T.TEMP r)
          ]))
        end
    | ifExp(test, then', NONE) =
        let
          val t = Temp.newlabel()
          val f = Temp.newlabel()
          val j = Temp.newlabel()
          val r = Temp.newtemp()
        in
          Ex(eseq([
            unCx(test)(t,f),
            T.LABEL t,
            T.MOVE(T.TEMP r, unEx then'),
            T.JUMP(T.NAME j, [j]),
            T.LABEL f,
            T.LABEL j,
            T.EXP(T.TEMP r)
          ]))
        end

  fun letExp(decs,body) = Ex(T.ESEQ(seq(map(unNx)decs), unEx(body)))

  (* array: exp * exp -> exp *)
  (* initArray simply takes the array length and initializing
   * value *)
  fun arrayExp(size, init) =
    Ex(Frame.externalCall("initArray", [unEx(size), unEx(init)]))

  (* handles sequences of expresssions *)
  fun seqExp(trans) = Ex(eseq(map(unNx)trans))

  (* it looks like the tiger runtime knows to treat the left hand side as a
   * location, rather than a value. *)
  fun assignExp(lval, rval) = Nx(T.MOVE(unEx lval, unEx rval))

  (* implementation of while loops *)
  fun whileExp(test, body, donelab) =
    let
      val checklab = Temp.newlabel()
      val bodylab = Temp.newlabel()
    in
      Nx(seq([
        T.LABEL checklab,
        unCx(test)(bodylab, donelab),
        T.LABEL bodylab,
        unNx body,
        T.JUMP(T.NAME checklab, [checklab]),
        T.LABEL donelab
      ]))
    end

  fun breakExp(lab) =
    Nx(T.JUMP(T.NAME lab,[lab]))

  (* nil is just a constant 0 *)
  fun nilExp() = Ex(T.CONST 0)

  (* unit exp is const 0*)
  fun unitExp() = Nx(T.EXP(T.CONST 0))
  
  (* handles integer consts *)
  fun intExp(i) = Ex(T.CONST i)

  (* saves a string literal as a name, and a fragment to frags *)
  fun stringExp(lit) = 
    let
      val lab= Temp.newlabel()
    in
      (frags := Frame.STRING(lab, lit):: !frags;
       Ex(T.NAME(lab)))
    end

  (* handles function calls *)
  fun callExp(func, args) = 
    Ex(T.CALL(T.NAME func, map(unEx)(args)))

  (* allocates some heap space for a record the fields placed in order of the
   * type declaration *)
  fun recordExp(fields) =
    let
      val r = Temp.newtemp()
      val ind = ref 0
      (* create all of the move instructions *)
      fun genstm(exp::rest) =
        let val i = !ind
        in
          (ind := !ind +1;
           T.MOVE(T.MEM(T.BINOP(T.PLUS, 
                                T.TEMP r,
                                T.CONST i)),
                  unEx exp)::genstm([]))
        end
        | genstm([]) = []
    in
      Ex(T.ESEQ(seq(
             T.MOVE(T.TEMP r,Frame.externalCall("malloc", 
                                         [T.BINOP(T.MUL, 
                                                  T.CONST Frame.wordSize, 
                                                  T.CONST(length(fields)))]))
             :: genstm(fields)), 
             T.TEMP r))
    end

  (* function calls *)
  fun procEntryExit(LEV(lev, frm, frmref), exp) : unit =
    let
      val lab= Temp.newlabel
    in
      (frags := Frame.PROC({body=unNx(exp), frame=frm}):: !frags;
       ())
    end
    | procEntryExit(BASE, exp) : unit = ()

  fun printtree(exp) = Printtree.printtree(TextIO.stdOut, unNx exp)

end
